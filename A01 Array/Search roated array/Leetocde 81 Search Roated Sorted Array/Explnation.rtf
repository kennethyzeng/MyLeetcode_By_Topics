{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 HelveticaNeue;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red51\green51\blue51;\red255\green255\blue255;\red29\green38\blue42;
\red245\green247\blue249;\red20\green0\blue196;\red151\green0\blue126;\red12\green90\blue1;}
{\*\expandedcolortbl;;\cssrgb\c25882\c25882\c25882;\cssrgb\c100000\c100000\c100000;\cssrgb\c14902\c19608\c21961;
\cssrgb\c96863\c97647\c98039;\cssrgb\c10980\c0\c81176;\cssrgb\c66667\c5098\c56863;\cssrgb\c0\c41569\c0;}
\margl1440\margr1440\vieww25100\viewh13280\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \
https://www.youtube.com/watch?v=dtySLSksPZI\
\
\
\pard\pardeftab720\sa280\partightenfactor0

\f1\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 class Solution \{\cb1 \uc0\u8232 \cb3 public boolean search(int[] nums, int target) \{\
\
\pard\pardeftab720\sl416\partightenfactor0

\f2\fs26 \cf4 \cb5 \strokec4     int i = \cf6 \strokec6 0\cf4 \strokec4 , j = nums.length - \cf6 \strokec6 1\cf4 \strokec4 ;\
    \
    \cf7 \strokec7 while\cf4 \strokec4 (i <= j) \{\
        \
        int m = (i + j) / \cf6 \strokec6 2\cf4 \strokec4 ;\
        \cf7 \strokec7 if\cf4 \strokec4 (nums[m] == target) \cf7 \strokec7 return\cf4 \strokec4  \cf7 \strokec7 true\cf4 \strokec4 ;\
        \
        \cf7 \strokec7 if\cf4 \strokec4 (nums[m] == nums[i]) i++;   \cf8 \strokec8 //"duplicate", jump\cf4 \strokec4 \
        \
        \cf8 \strokec8 // we are on the 'bigger' increasing side, like [5,5,7] from [5,5,7,0,1,3,4]\cf4 \strokec4 \
        \cf7 \strokec7 else\cf4 \strokec4  \cf7 \strokec7 if\cf4 \strokec4 (nums[m] > nums[i]) \{\
            \
            \cf8 \strokec8 // if target is between nums[i] and nums[m], it makes sense to set the right border to m-1\cf4 \strokec4 \
            \cf7 \strokec7 if\cf4 \strokec4 (nums[m] > target && nums[i] <= target) j = m - \cf6 \strokec6 1\cf4 \strokec4 ; \
            \cf8 \strokec8 // if target is NOT between nums[i] and nums[m] then target is on the 'right' side of m ; limit the 'left' border [i=m+1]\cf4 \strokec4 \
            \cf7 \strokec7 else\cf4 \strokec4  i = m + \cf6 \strokec6 1\cf4 \strokec4 ;\
\
        \cf8 \strokec8 // case nums[m] < nums[i] : we are on the 'smaller' increasing side, like [0,1,3,4] from [5,5,7,0,1,3,4] \cf4 \strokec4 \
        \} \cf7 \strokec7 else\cf4 \strokec4  \{\
            \
            \cf8 \strokec8 // if target is between nums[m] and nums[j], it makes sense to set the left border to m+1\cf4 \strokec4 \
            \cf7 \strokec7 if\cf4 \strokec4 (nums[m] < target && nums[j] >= target) i = m + \cf6 \strokec6 1\cf4 \strokec4 ;\
            \cf8 \strokec8 // if target is NOT between nums[m] and nums[j] then target is on the 'left' side of m ; limit the 'right' border [j=m-1]\cf4 \strokec4 \
            \cf7 \strokec7 else\cf4 \strokec4  j = m - \cf6 \strokec6 1\cf4 \strokec4 ;\
        \}\
    \}\
    \cf7 \strokec7 return\cf4 \strokec4  \cf7 \strokec7 false\cf4 \strokec4 ;\
\}\
}