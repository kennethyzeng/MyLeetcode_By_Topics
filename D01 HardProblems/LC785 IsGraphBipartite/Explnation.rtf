{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue0;\red255\green255\blue255;
\red71\green138\blue206;\red203\green203\blue202;\red67\green192\blue160;\red212\green213\blue153;\red141\green213\blue254;
\red183\green111\blue179;\red88\green137\blue67;\red167\green197\blue151;\red0\green0\blue0;\red203\green203\blue202;
\red202\green202\blue202;}
{\*\expandedcolortbl;;\cssrgb\c0\c1\c1;\cssrgb\c0\c1\c1;\cssrgb\c100000\c100000\c100000;
\cssrgb\c34146\c61677\c84338;\cssrgb\c83320\c83320\c83112;\cssrgb\c30631\c78928\c69023;\cssrgb\c86247\c86215\c66392;\cssrgb\c61545\c86704\c99884;
\cssrgb\c77407\c52698\c75307;\cssrgb\c41481\c59899\c33082;\cssrgb\c71035\c80830\c65726;\cssrgb\c0\c1\c1;\cssrgb\c83320\c83320\c83112;
\cssrgb\c83137\c83137\c83137;}
\margl1440\margr1440\vieww25100\viewh13280\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Method 1:  BFS + queue\
https://www.youtube.com/watch?v=670Gn4e89B8\
\
\
\
\
\
\
\
\
\
Method 2: DFS\
\
\
\cf2 ######BFS.  		table 1: red.       Table 2: green\
\pard\pardeftab720\sl360\partightenfactor0

\f1 \cf3 \cb4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 class\cf3 \strokec6  \cf3 \strokec7 Solution\cf3 \strokec6  \{\
    \cf3 \strokec5 public\cf3 \strokec6  \cf3 \strokec7 boolean\cf3 \strokec6  \cf3 \strokec8 isBipartite\cf3 \strokec6 (\cf3 \strokec7 int\cf3 \strokec6 [][] \cf3 \strokec9 graph\cf3 \strokec6 ) \{\
        \cf3 \strokec7 int\cf3 \strokec6 [] \cf3 \strokec9 visited\cf3 \strokec6  = \cf3 \strokec10 new\cf3 \strokec6  \cf3 \strokec7 int\cf3 \strokec6 [\cf3 \strokec9 graph\cf3 \strokec6 .\cf3 \strokec9 length\cf3 \strokec6 ]; 				\cf3 \strokec11 //default 0: not visited\cf3 \strokec6 \
       \cf3 \strokec10 for\cf3 \strokec6  (\cf3 \strokec7 int\cf3 \strokec6  \cf3 \strokec9 i\cf3 \strokec6  = \cf3 \strokec12 0\cf3 \strokec6 ; i < \cf3 \strokec9 graph\cf3 \strokec6 .\cf3 \strokec9 length\cf3 \strokec6 ; i++)\{\
           \cf3 \strokec10 if\cf3 \strokec6  (visited[i] != \cf3 \strokec12 0\cf3 \strokec6 ) \{							//if visited already, skip and continue rest\
               \cf3 \strokec10 continue\cf3 \strokec6 ; \
           \}\
           \cf3 \strokec7 Queue\cf3 \strokec6 <\cf3 \strokec7 Integer\cf3 \strokec6 > \cf3 \strokec9 queue\cf3 \strokec6  = \cf3 \strokec10 new\cf3 \strokec6  \cf3 \strokec8 LinkedList\cf3 \strokec6 ();			//Queue for BFS\
           \cf3 \strokec9 queue\cf3 \strokec6 .\cf3 \strokec8 add\cf3 \strokec6 (i);\
           visited[i] = \cf3 \strokec12 1\cf3 \strokec6 ; \cf3 \strokec11 //mark as red\cf3 \strokec6 \
           \cf3 \strokec10 while\cf3 \strokec6  (!\cf3 \strokec9 queue\cf3 \strokec6 .\cf3 \strokec8 isEmpty\cf3 \strokec6 ())\{\
               \cf3 \strokec7 int\cf3 \strokec6  \cf3 \strokec9 cur\cf3 \strokec6  = \cf3 \strokec9 queue\cf3 \strokec6 .\cf3 \strokec8 poll\cf3 \strokec6 (); 						//store number from poll of Queue\
               \cf3 \strokec7 int\cf3 \strokec6  \cf3 \strokec9 curLable\cf3 \strokec6  = visited[cur];					//check the color for the poll number of Queue(curlable).    \
               \cf3 \strokec7 int\cf3 \strokec6  \cf3 \strokec9 neighborLable\cf3 \strokec6  = curLable ==\cf3 \strokec12 1\cf3 \strokec10 ?\cf3 \strokec6  \cf3 \strokec12 2\cf3 \strokec10 :\cf3 \strokec6  \cf3 \strokec12 1\cf3 \strokec6 ; 		//set the color for adjacent node or edge: if curlable =1, then adjacent node /edget =2; \
													//also, if curlable =2, then rest is 1\
               \cf3 \strokec10 for\cf3 \strokec6  (\cf3 \strokec7 int\cf3 \strokec6  \cf3 \strokec9 neighbor\cf3 \strokec6  \cf3 \strokec10 :\cf3 \strokec6  graph[cur])\{\
                   \cf3 \strokec10 if\cf3 \strokec6 (visited[neighbor] == \cf3 \strokec12 0\cf3 \strokec6 )\{				//if not visited                       \
				   visited[neighbor] = neighborLable; 		//\cf13 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 , set visited(neighbor) have same color as neighborlable since node is created by (adjacent number)\cf3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec6 \
                       \cf3 \strokec9 queue\cf3 \strokec6 .\cf3 \strokec8 add\cf3 \strokec6 (neighbor); \
                   \}\cf3 \strokec10 else\cf3 \strokec6  \cf3 \strokec10 if\cf3 \strokec6 (visited[neighbor] != neighborLable)\{     //actually, one more condition here which didn\'92t mention.  \cf13 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 visited[neighbor] == neighborLable\cf3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec6 \
                       \cf3 \strokec10 return\cf3 \strokec6  \cf3 \strokec5 false\cf3 \strokec6 ;\
                   \}\
               \}\
           \}\
       \}\
        \cf3 \strokec10 return\cf3 \strokec6  \cf3 \strokec5 true\cf3 \strokec6 ;  \
    \}\
\}\cf15 \cb1 \strokec15 \
\pard\pardeftab720\sl360\partightenfactor0
\cf15 \
}