{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\fmodern\fcharset0 Courier;\f2\fnil\fcharset0 HelveticaNeue-Bold;
\f3\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red51\green51\blue51;\red255\green255\blue255;\red67\green91\blue103;
\red245\green247\blue249;\red78\green106\blue120;\red151\green0\blue126;\red29\green38\blue42;\red73\green17\blue135;
\red20\green0\blue196;\red12\green90\blue1;\red181\green0\blue19;}
{\*\expandedcolortbl;;\cssrgb\c25882\c25882\c25882;\cssrgb\c100000\c100000\c100000;\cssrgb\c32941\c43137\c47843;
\cssrgb\c96863\c97647\c98039;\cssrgb\c37647\c49020\c54510;\cssrgb\c66667\c5098\c56863;\cssrgb\c14902\c19608\c21961;\cssrgb\c36078\c14902\c60000;
\cssrgb\c10980\c0\c81176;\cssrgb\c0\c41569\c0;\cssrgb\c76863\c10196\c8627;}
\margl1440\margr1440\vieww25100\viewh13280\viewkind0
\deftab720
\pard\pardeftab720\sa280\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 If you're a newbie and sometimes have a hard time understanding the logic. Don't worry, you'll catch up after a month of doing Leetcode on a daily basis. Try to do it, even one example per day. It'd help. I've compiled a bunch on\'a0
\f1\fs26 \cf4 \cb5 \strokec4 sum
\f0\fs28 \cf2 \cb3 \strokec2 \'a0problems here, go ahead and check it out. Also, I think focusing on a subject and do 3-4 problems would help to get the idea behind solution since they mostly follow the same logic. Of course there are other ways to solve each problems but I try to be as uniform as possible. Good luck.\
\
In general,\'a0
\f1\fs26 \cf4 \cb5 \strokec4 sum
\f0\fs28 \cf2 \cb3 \strokec2 \'a0problems can be categorized into two categories: 1) there is any array and you add some numbers to get to (or close to) a\'a0
\f1\fs26 \cf4 \cb5 \strokec4 target
\f0\fs28 \cf2 \cb3 \strokec2 , or 2) you need to return indices of numbers that sum up to a (or close to) a\'a0
\f1\fs26 \cf4 \cb5 \strokec4 target
\f0\fs28 \cf2 \cb3 \strokec2 \'a0value. Note that when the problem is looking for a indices,\'a0
\f1\fs26 \cf4 \cb5 \strokec4 sort
\f0\fs28 \cf2 \cb3 \strokec2 ing the array is probably NOT a good idea.\
\
{\field{\*\fldinst{HYPERLINK "https://leetcode.com/problems/two-sum/"}}{\fldrslt 
\f2\b \cf6 \strokec6 Two Sum:}}\
\
This is the second type of the problems where we're looking for indices, so sorting is not necessary. What you'd want to do is to go over the array, and try to find two integers that sum up to a\'a0
\f1\fs26 \cf4 \cb5 \strokec4 target
\f0\fs28 \cf2 \cb3 \strokec2 \'a0value. Most of the times, in such a problem, using dictionary (hastable) helps. You try to keep track of you've observations in a dictionary and use it once you get to the results.\
\
Note: try to be comfortable to use\'a0
\f1\fs26 \cf4 \cb5 \strokec4 enumerate
\f0\fs28 \cf2 \cb3 \strokec2 \'a0as it's sometime out of comfort zone for newbies.\'a0
\f1\fs26 \cf4 \cb5 \strokec4 enumerate
\f0\fs28 \cf2 \cb3 \strokec2 \'a0comes handy in a lot of problems (I mean if you want to have a cleaner code of course). If I had to choose three built in functions/methods that I wasn't comfortable with at the start and have found them super helpful, I'd probably say\'a0
\f1\fs26 \cf4 \cb5 \strokec4 enumerate
\f0\fs28 \cf2 \cb3 \strokec2 ,\'a0
\f1\fs26 \cf4 \cb5 \strokec4 zip
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and\'a0
\f1\fs26 \cf4 \cb5 \strokec4 set
\f0\fs28 \cf2 \cb3 \strokec2 .\
\
Solution: In this problem, you initialize a dictionary (
\f1\fs26 \cf4 \cb5 \strokec4 seen
\f0\fs28 \cf2 \cb3 \strokec2 ). This dictionary will keep track of numbers (as\'a0
\f1\fs26 \cf4 \cb5 \strokec4 key
\f0\fs28 \cf2 \cb3 \strokec2 ) and indices (as\'a0
\f1\fs26 \cf4 \cb5 \strokec4 value
\f0\fs28 \cf2 \cb3 \strokec2 ). So, you go over your array (line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #1
\f0\fs28 \cf2 \cb3 \strokec2 ) using\'a0
\f1\fs26 \cf4 \cb5 \strokec4 enumerate
\f0\fs28 \cf2 \cb3 \strokec2 \'a0that gives you both index and value of elements in array. As an example, let's do\'a0
\f1\fs26 \cf4 \cb5 \strokec4 nums = [2,3,1]
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and\'a0
\f1\fs26 \cf4 \cb5 \strokec4 target = 3
\f0\fs28 \cf2 \cb3 \strokec2 . Let's say you're at index\'a0
\f1\fs26 \cf4 \cb5 \strokec4 i = 0
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and\'a0
\f1\fs26 \cf4 \cb5 \strokec4 value = 2
\f0\fs28 \cf2 \cb3 \strokec2 , ok? you need to find\'a0
\f1\fs26 \cf4 \cb5 \strokec4 value = 1
\f0\fs28 \cf2 \cb3 \strokec2 \'a0to finish the problem, meaning,\'a0
\f1\fs26 \cf4 \cb5 \strokec4 target - 2 = 1
\f0\fs28 \cf2 \cb3 \strokec2 . 1 here is the\'a0
\f1\fs26 \cf4 \cb5 \strokec4 remaining
\f0\fs28 \cf2 \cb3 \strokec2 . Since\'a0
\f1\fs26 \cf4 \cb5 \strokec4 remaining + value = target
\f0\fs28 \cf2 \cb3 \strokec2 , you're done once you found it, right? So when going through the array, you calculate the\'a0
\f1\fs26 \cf4 \cb5 \strokec4 remaining
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and check to see whether\'a0
\f1\fs26 \cf4 \cb5 \strokec4 remaining
\f0\fs28 \cf2 \cb3 \strokec2 \'a0is in the\'a0
\f1\fs26 \cf4 \cb5 \strokec4 seen
\f0\fs28 \cf2 \cb3 \strokec2 \'a0dictionary (line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #3
\f0\fs28 \cf2 \cb3 \strokec2 ). If it is, you're done! you're current number and the remaining from\'a0
\f1\fs26 \cf4 \cb5 \strokec4 seen
\f0\fs28 \cf2 \cb3 \strokec2 \'a0would give you the output (line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #4
\f0\fs28 \cf2 \cb3 \strokec2 ). Otherwise, you add your current number to the dictionary (line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #5
\f0\fs28 \cf2 \cb3 \strokec2 ) since it's going to be a\'a0
\f1\fs26 \cf4 \cb5 \strokec4 remaining
\f0\fs28 \cf2 \cb3 \strokec2 \'a0for (probably) a number you'll see in the future assuming that there is at least one instance of answer.\
\
\pard\pardeftab720\sl416\partightenfactor0

\f3\fs26 \cf7 \cb5 \strokec7 class\cf8 \strokec8  \cf9 \strokec9 Solution\cf8 \strokec8 :\
   \cf7 \strokec7 def\cf8 \strokec8  \cf10 \strokec10 twoSum\cf8 \strokec8 (\cf9 \strokec9 self, nums: List[int], target: int\cf8 \strokec8 ) -> List[int]:\
       seen = \{\}\
       \cf7 \strokec7 for\cf8 \strokec8  i, value \cf7 \strokec7 in\cf8 \strokec8  \cf9 \strokec9 enumerate\cf8 \strokec8 (nums): \cf11 \strokec11 #1\cf8 \strokec8 \
           remaining = target - nums[i] \cf11 \strokec11 #2\cf8 \strokec8 \
           \
           \cf7 \strokec7 if\cf8 \strokec8  remaining \cf7 \strokec7 in\cf8 \strokec8  seen: \cf11 \strokec11 #3\cf8 \strokec8 \
               \cf7 \strokec7 return\cf8 \strokec8  [i, seen[remaining]]  \cf11 \strokec11 #4\cf8 \strokec8 \
           \cf7 \strokec7 else\cf8 \strokec8 :\
               seen[value] = i  \cf11 \strokec11 #5\cf8 \strokec8 \
\pard\pardeftab720\sa280\partightenfactor0

\f0\fs28 \cf2 \cb3 \strokec2 \
\pard\pardeftab720\sa280\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"}}{\fldrslt 
\f2\b \cf6 \strokec6 Two Sum II:}}\
\
For this, you can do exactly as the previous. The only change I made below was to change the order of line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #4
\f0\fs28 \cf2 \cb3 \strokec2 . In the previous example, the order didn't matter. But, here the problem asks for asending order and since the values/indicess in\'a0
\f1\fs26 \cf4 \cb5 \strokec4 seen
\f0\fs28 \cf2 \cb3 \strokec2 \'a0has always lower indices than your current number, it should come first. Also, note that the problem says it's not zero based, meaning that indices don't start from zero, that's why I added 1 to both of them.\
\
\pard\pardeftab720\sl416\partightenfactor0

\f3\fs26 \cf7 \cb5 \strokec7 class\cf8 \strokec8  \cf9 \strokec9 Solution\cf8 \strokec8 :\
    \cf7 \strokec7 def\cf8 \strokec8  \cf10 \strokec10 twoSum\cf8 \strokec8 (\cf9 \strokec9 self, numbers: List[int], target: int\cf8 \strokec8 ) -> List[int]:\
        \
        seen = \{\}\
        \cf7 \strokec7 for\cf8 \strokec8  i, value \cf7 \strokec7 in\cf8 \strokec8  \cf9 \strokec9 enumerate\cf8 \strokec8 (numbers): \
            remaining = target - numbers[i] \
           \
            \cf7 \strokec7 if\cf8 \strokec8  remaining \cf7 \strokec7 in\cf8 \strokec8  seen: \
                \cf7 \strokec7 return\cf8 \strokec8  [seen[remaining]+\cf10 \strokec10 1\cf8 \strokec8 , i+\cf10 \strokec10 1\cf8 \strokec8 ]  \cf11 \strokec11 #4\cf8 \strokec8 \
            \cf7 \strokec7 else\cf8 \strokec8 :\
                seen[value] = i  \
\pard\pardeftab720\sa280\partightenfactor0

\f0\fs28 \cf2 \cb3 \strokec2 \
Another approach to solve this problem (probably what Leetcode is looking for) is to treat it as first category of problems. Since the array is already sorted, this works. You see the following approach in a lot of problems. What you want to do is to have two pointer (if it was 3sum, you'd need three pointers as you'll see in the future examples). One pointer move from\'a0
\f1\fs26 \cf4 \cb5 \strokec4 left
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and one from\'a0
\f1\fs26 \cf4 \cb5 \strokec4 right
\f0\fs28 \cf2 \cb3 \strokec2 . Let's say you\'a0
\f1\fs26 \cf4 \cb5 \strokec4 numbers = [1,3,6,9]
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and your\'a0
\f1\fs26 \cf4 \cb5 \strokec4 target = 10
\f0\fs28 \cf2 \cb3 \strokec2 . Now,\'a0
\f1\fs26 \cf4 \cb5 \strokec4 left
\f0\fs28 \cf2 \cb3 \strokec2 \'a0points to 1 at first, and\'a0
\f1\fs26 \cf4 \cb5 \strokec4 right
\f0\fs28 \cf2 \cb3 \strokec2 \'a0points to 9. There are three possibilities. If you sum numbers that\'a0
\f1\fs26 \cf4 \cb5 \strokec4 left
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and\'a0
\f1\fs26 \cf4 \cb5 \strokec4 right
\f0\fs28 \cf2 \cb3 \strokec2 \'a0are pointing at, you get\'a0
\f1\fs26 \cf4 \cb5 \strokec4 temp_sum
\f0\fs28 \cf2 \cb3 \strokec2 \'a0(line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #1
\f0\fs28 \cf2 \cb3 \strokec2 ). If\'a0
\f1\fs26 \cf4 \cb5 \strokec4 temp_sum
\f0\fs28 \cf2 \cb3 \strokec2 \'a0is your target, you'r done! You're return it (line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #9
\f0\fs28 \cf2 \cb3 \strokec2 ). If it's more than your\'a0
\f1\fs26 \cf4 \cb5 \strokec4 target
\f0\fs28 \cf2 \cb3 \strokec2 , it means that\'a0
\f1\fs26 \cf4 \cb5 \strokec4 right
\f0\fs28 \cf2 \cb3 \strokec2 \'a0is poiting to a very large value (line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #5
\f0\fs28 \cf2 \cb3 \strokec2 ) and you need to bring it a little bit to the left to a smaller (r maybe equal) value (line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #6
\f0\fs28 \cf2 \cb3 \strokec2 ) by adding one to the index . If the\'a0
\f1\fs26 \cf4 \cb5 \strokec4 temp_sum
\f0\fs28 \cf2 \cb3 \strokec2 \'a0is less than\'a0
\f1\fs26 \cf4 \cb5 \strokec4 target
\f0\fs28 \cf2 \cb3 \strokec2 \'a0(line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #7
\f0\fs28 \cf2 \cb3 \strokec2 ), then you need to move your\'a0
\f1\fs26 \cf4 \cb5 \strokec4 left
\f0\fs28 \cf2 \cb3 \strokec2 \'a0to a little bit larger value by adding one to the index (line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #9
\f0\fs28 \cf2 \cb3 \strokec2 ). This way, you try to narrow down the range in which you're looking at and will eventually find a couple of number that sum to\'a0
\f1\fs26 \cf4 \cb5 \strokec4 target
\f0\fs28 \cf2 \cb3 \strokec2 , then, you'll return this in line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #9
\f0\fs28 \cf2 \cb3 \strokec2 . In this problem, since it says there is only one solution, nothing extra is necessary. However, when a problem asks to return all combinations that sum to\'a0
\f1\fs26 \cf4 \cb5 \strokec4 target
\f0\fs28 \cf2 \cb3 \strokec2 , you can't simply return the first instace and you need to collect all the possibilities and return the list altogether (you'll see something like this in the next example).\
\
\pard\pardeftab720\sl416\partightenfactor0

\f3\fs26 \cf7 \cb5 \strokec7 class\cf8 \strokec8  \cf9 \strokec9 Solution\cf8 \strokec8 :\
    \cf7 \strokec7 def\cf8 \strokec8  \cf10 \strokec10 twoSum\cf8 \strokec8 (\cf9 \strokec9 self, numbers: List[int], target: int\cf8 \strokec8 ) -> List[int]:\
        \
        \cf7 \strokec7 for\cf8 \strokec8  left \cf7 \strokec7 in\cf8 \strokec8  \cf9 \strokec9 range\cf8 \strokec8 (\cf9 \strokec9 len\cf8 \strokec8 (numbers) -\cf10 \strokec10 1\cf8 \strokec8 ): \cf11 \strokec11 #1\cf8 \strokec8 \
            right = \cf9 \strokec9 len\cf8 \strokec8 (numbers) - \cf10 \strokec10 1\cf8 \strokec8  \cf11 \strokec11 #2\cf8 \strokec8 \
            \cf7 \strokec7 while\cf8 \strokec8  left < right: \cf11 \strokec11 #3\cf8 \strokec8 \
                temp_sum = numbers[left] + numbers[right] \cf11 \strokec11 #4\cf8 \strokec8 \
                \cf7 \strokec7 if\cf8 \strokec8  temp_sum > target:  \cf11 \strokec11 #5\cf8 \strokec8 \
                    right -= \cf10 \strokec10 1\cf8 \strokec8  \cf11 \strokec11 #6\cf8 \strokec8 \
                \cf7 \strokec7 elif\cf8 \strokec8  temp_sum < target: \cf11 \strokec11 #7\cf8 \strokec8 \
                    left +=\cf10 \strokec10 1\cf8 \strokec8  \cf11 \strokec11 #8\cf8 \strokec8 \
                \cf7 \strokec7 else\cf8 \strokec8 :\
                    \cf7 \strokec7 return\cf8 \strokec8  [left+\cf10 \strokec10 1\cf8 \strokec8 , right+\cf10 \strokec10 1\cf8 \strokec8 ] \cf11 \strokec11 #9\cf8 \strokec8 \
\pard\pardeftab720\sa280\partightenfactor0

\f0\fs28 \cf2 \cb3 \strokec2 \
\pard\pardeftab720\sa280\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://leetcode.com/problems/3sum/"}}{\fldrslt 
\f2\b \cf6 \strokec6 3Sum}}\
\
This is similar to the previous example except that it's looking for three numbers. There are some minor differences in the problem statement. It's looking for all combinations (not just one) of solutions returned as a list. And second, it's looking for unique combination, repeatation is not allowed.\
\
Here, instead of looping (line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #1
\f0\fs28 \cf2 \cb3 \strokec2 ) to\'a0
\f1\fs26 \cf4 \cb5 \strokec4 len(nums) -1
\f0\fs28 \cf2 \cb3 \strokec2 , we loop to\'a0
\f1\fs26 \cf4 \cb5 \strokec4 len(nums) -2
\f0\fs28 \cf2 \cb3 \strokec2 \'a0since we're looking for three numbers. Since we're returning values,\'a0
\f1\fs26 \cf4 \cb5 \strokec4 sort
\f0\fs28 \cf2 \cb3 \strokec2 \'a0would be a good idea. Otherwise, if the\'a0
\f1\fs26 \cf4 \cb5 \strokec4 nums
\f0\fs28 \cf2 \cb3 \strokec2 \'a0is not sorted, you cannot reducing\'a0
\f1\fs26 \cf4 \cb5 \strokec4 right
\f0\fs28 \cf2 \cb3 \strokec2 \'a0pointer or increasing\'a0
\f1\fs26 \cf4 \cb5 \strokec4 left
\f0\fs28 \cf2 \cb3 \strokec2 \'a0pointer easily, makes sense?\
\
So, first you\'a0
\f1\fs26 \cf4 \cb5 \strokec4 sort
\f0\fs28 \cf2 \cb3 \strokec2 \'a0the array and define\'a0
\f1\fs26 \cf4 \cb5 \strokec4 res = []
\f0\fs28 \cf2 \cb3 \strokec2 \'a0to collect your outputs. In line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #2
\f0\fs28 \cf2 \cb3 \strokec2 , we check wether two consecutive elements are equal or not because if they are, we don't want them (solutions need to be unique) and will skip to the next set of numbers. Also, there is an additional constrain in this line that\'a0
\f1\fs26 \cf4 \cb5 \strokec4 i > 0
\f0\fs28 \cf2 \cb3 \strokec2 . This is added to take care of cases like\'a0
\f1\fs26 \cf4 \cb5 \strokec4 nums = [1,1,1]
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and\'a0
\f1\fs26 \cf4 \cb5 \strokec4 target = 3
\f0\fs28 \cf2 \cb3 \strokec2 . If we didn't have\'a0
\f1\fs26 \cf4 \cb5 \strokec4 i > 0
\f0\fs28 \cf2 \cb3 \strokec2 , then we'd skip the only correct solution and would return\'a0
\f1\fs26 \cf4 \cb5 \strokec4 []
\f0\fs28 \cf2 \cb3 \strokec2 \'a0as our answer which is wrong (correct answer is\'a0
\f1\fs26 \cf4 \cb5 \strokec4 [[1,1,1]]
\f0\fs28 \cf2 \cb3 \strokec2 .\
\
We define two additional pointers this time,\'a0
\f1\fs26 \cf4 \cb5 \strokec4 left = i + 1
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and\'a0
\f1\fs26 \cf4 \cb5 \strokec4 right = len(nums) - 1
\f0\fs28 \cf2 \cb3 \strokec2 . For example, if\'a0
\f1\fs26 \cf4 \cb5 \strokec4 nums = [-2,-1,0,1,2]
\f0\fs28 \cf2 \cb3 \strokec2 , all the points in the case of\'a0
\f1\fs26 \cf4 \cb5 \strokec4 i=1
\f0\fs28 \cf2 \cb3 \strokec2 \'a0are looking at:\'a0
\f1\fs26 \cf4 \cb5 \strokec4 i
\f0\fs28 \cf2 \cb3 \strokec2 \'a0at\'a0
\f1\fs26 \cf4 \cb5 \strokec4 -1
\f0\fs28 \cf2 \cb3 \strokec2 ,\'a0
\f1\fs26 \cf4 \cb5 \strokec4 left
\f0\fs28 \cf2 \cb3 \strokec2 \'a0at\'a0
\f1\fs26 \cf4 \cb5 \strokec4 0
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and\'a0
\f1\fs26 \cf4 \cb5 \strokec4 right
\f0\fs28 \cf2 \cb3 \strokec2 \'a0at\'a0
\f1\fs26 \cf4 \cb5 \strokec4 2
\f0\fs28 \cf2 \cb3 \strokec2 . We then check\'a0
\f1\fs26 \cf4 \cb5 \strokec4 temp
\f0\fs28 \cf2 \cb3 \strokec2 \'a0variable similar to the previous example. There is only one change with respect to the previous example here between lines\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #5
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #10
\f0\fs28 \cf2 \cb3 \strokec2 . If we have the\'a0
\f1\fs26 \cf4 \cb5 \strokec4 temp = target
\f0\fs28 \cf2 \cb3 \strokec2 , we obviously add this set to the\'a0
\f1\fs26 \cf4 \cb5 \strokec4 res
\f0\fs28 \cf2 \cb3 \strokec2 \'a0in line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #5
\f0\fs28 \cf2 \cb3 \strokec2 , right? However, we're not done yet. For a fixed\'a0
\f1\fs26 \cf4 \cb5 \strokec4 i
\f0\fs28 \cf2 \cb3 \strokec2 , we still need to check and see whether there are other combinations by just changing\'a0
\f1\fs26 \cf4 \cb5 \strokec4 left
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and\'a0
\f1\fs26 \cf4 \cb5 \strokec4 right
\f0\fs28 \cf2 \cb3 \strokec2 \'a0pointers. That's what we are doing in lines\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #6, 7, 8
\f0\fs28 \cf2 \cb3 \strokec2 . If we still have the condition of\'a0
\f1\fs26 \cf4 \cb5 \strokec4 left < right
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and\'a0
\f1\fs26 \cf4 \cb5 \strokec4 nums[left]
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and the number to the right of it are not the same, we move\'a0
\f1\fs26 \cf4 \cb5 \strokec4 left
\f0\fs28 \cf2 \cb3 \strokec2 \'a0one index to right (line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #6
\f0\fs28 \cf2 \cb3 \strokec2 ). Similarly, if\'a0
\f1\fs26 \cf4 \cb5 \strokec4 nums[right]
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and the value to left of it is not the same, we move\'a0
\f1\fs26 \cf4 \cb5 \strokec4 right
\f0\fs28 \cf2 \cb3 \strokec2 \'a0one index to left. This way for a fixed\'a0
\f1\fs26 \cf4 \cb5 \strokec4 i
\f0\fs28 \cf2 \cb3 \strokec2 , we get rid of repeative cases. For example, if\'a0
\f1\fs26 \cf4 \cb5 \strokec4 nums = [-3, 1,1, 3,5]
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and\'a0
\f1\fs26 \cf4 \cb5 \strokec4 target = 3
\f0\fs28 \cf2 \cb3 \strokec2 , one we get the first\'a0
\f1\fs26 \cf4 \cb5 \strokec4 [-3,1,5]
\f0\fs28 \cf2 \cb3 \strokec2 ,\'a0
\f1\fs26 \cf4 \cb5 \strokec4 left = 1
\f0\fs28 \cf2 \cb3 \strokec2 , but,\'a0
\f1\fs26 \cf4 \cb5 \strokec4 nums[2]
\f0\fs28 \cf2 \cb3 \strokec2 \'a0is also 1 which we don't want the\'a0
\f1\fs26 \cf4 \cb5 \strokec4 left
\f0\fs28 \cf2 \cb3 \strokec2 \'a0variable to look at it simply because it'd again return\'a0
\f1\fs26 \cf4 \cb5 \strokec4 [-3,1,5]
\f0\fs28 \cf2 \cb3 \strokec2 , right? So, we move\'a0
\f1\fs26 \cf4 \cb5 \strokec4 left
\f0\fs28 \cf2 \cb3 \strokec2 \'a0one index. Finally, if the repeating elements don't exists, lines\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #6
\f0\fs28 \cf2 \cb3 \strokec2 \'a0to\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #8
\f0\fs28 \cf2 \cb3 \strokec2 \'a0won't get activated. In this case we still need to move forward by adding 1 to\'a0
\f1\fs26 \cf4 \cb5 \strokec4 left
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and extracting 1 from\'a0
\f1\fs26 \cf4 \cb5 \strokec4 right
\f0\fs28 \cf2 \cb3 \strokec2 \'a0(lines\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #9, 10
\f0\fs28 \cf2 \cb3 \strokec2 ).\
\
\pard\pardeftab720\sl416\partightenfactor0

\f3\fs26 \cf7 \cb5 \strokec7 class\cf8 \strokec8  \cf9 \strokec9 Solution\cf8 \strokec8 :\
    \cf7 \strokec7 def\cf8 \strokec8  \cf10 \strokec10 threeSum\cf8 \strokec8 (\cf9 \strokec9 self, nums: List[int]\cf8 \strokec8 ) -> List[List[int]]:\
        \
        nums.sort()\
        res = []\
\
        \cf7 \strokec7 for\cf8 \strokec8  i \cf7 \strokec7 in\cf8 \strokec8  \cf9 \strokec9 range\cf8 \strokec8 (\cf9 \strokec9 len\cf8 \strokec8 (nums) -\cf10 \strokec10 2\cf8 \strokec8 ): \cf11 \strokec11 #1\cf8 \strokec8 \
            \cf7 \strokec7 if\cf8 \strokec8  i > \cf10 \strokec10 0\cf8 \strokec8  \cf7 \strokec7 and\cf8 \strokec8  nums[i] == nums[i-\cf10 \strokec10 1\cf8 \strokec8 ]: \cf11 \strokec11 #2\cf8 \strokec8 \
                \cf7 \strokec7 continue\cf8 \strokec8 \
            left = i + \cf10 \strokec10 1\cf8 \strokec8  \cf11 \strokec11 #3\cf8 \strokec8 \
            right = \cf9 \strokec9 len\cf8 \strokec8 (nums) - \cf10 \strokec10 1\cf8 \strokec8  \cf11 \strokec11 #4\cf8 \strokec8 \
            \
            \cf7 \strokec7 while\cf8 \strokec8  left < right:  \
                temp = nums[i] + nums[left] + nums[right]\
                                    \
                \cf7 \strokec7 if\cf8 \strokec8  temp > \cf10 \strokec10 0\cf8 \strokec8 :\
                    right -= \cf10 \strokec10 1\cf8 \strokec8 \
                    \
                \cf7 \strokec7 elif\cf8 \strokec8  temp < \cf10 \strokec10 0\cf8 \strokec8 :\
                    left += \cf10 \strokec10 1\cf8 \strokec8 \
                \
                \cf7 \strokec7 else\cf8 \strokec8 :\
                    res.append([nums[i], nums[left], nums[right]]) \cf11 \strokec11 #5\cf8 \strokec8 \
                    \cf7 \strokec7 while\cf8 \strokec8  left < right \cf7 \strokec7 and\cf8 \strokec8  nums[left] == nums[left + \cf10 \strokec10 1\cf8 \strokec8 ]: \cf11 \strokec11 #6\cf8 \strokec8 \
                        left += \cf10 \strokec10 1\cf8 \strokec8 \
                    \cf7 \strokec7 while\cf8 \strokec8  left < right \cf7 \strokec7 and\cf8 \strokec8  nums[right] == nums[right-\cf10 \strokec10 1\cf8 \strokec8 ]:\cf11 \strokec11 #7\cf8 \strokec8 \
                        right -= \cf10 \strokec10 1\cf8 \strokec8     \cf11 \strokec11 #8\cf8 \strokec8 \
                \
                    right -= \cf10 \strokec10 1\cf8 \strokec8  \cf11 \strokec11 #9 \cf8 \strokec8 \
                    left += \cf10 \strokec10 1\cf8 \strokec8  \cf11 \strokec11 #10\cf8 \strokec8 \
                       \
\pard\pardeftab720\sa280\partightenfactor0

\f0\fs28 \cf2 \cb3 \strokec2 \
Another way to solve this problem is to change it into a two sum problem. Instead of finding\'a0
\f1\fs26 \cf4 \cb5 \strokec4 a+b+c = 0
\f0\fs28 \cf2 \cb3 \strokec2 , you can find\'a0
\f1\fs26 \cf4 \cb5 \strokec4 a+b = -c
\f0\fs28 \cf2 \cb3 \strokec2 \'a0where we want to find two numbers\'a0
\f1\fs26 \cf4 \cb5 \strokec4 a
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and\'a0
\f1\fs26 \cf4 \cb5 \strokec4 b
\f0\fs28 \cf2 \cb3 \strokec2 \'a0that are equal to\'a0
\f1\fs26 \cf4 \cb5 \strokec4 -c
\f0\fs28 \cf2 \cb3 \strokec2 , right? This is similar to the first problem. Remember if you wanted to use the exact same as the first code, it'd return indices and not numbers. Also, we need to re-arrage this problem in a way that we have\'a0
\f1\fs26 \cf4 \cb5 \strokec4 nums
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and\'a0
\f1\fs26 \cf4 \cb5 \strokec4 target
\f0\fs28 \cf2 \cb3 \strokec2 . This code is not a good code and can be optimipized but you got the idea. For a better version of this, check\'a0{\field{\*\fldinst{HYPERLINK "https://leetcode.com/problems/3sum/discuss/7384/My-Python-solution-based-on-2-sum-200-ms-beat-93.37"}}{\fldrslt \cf6 \strokec6 this}}.\
\
\pard\pardeftab720\sl416\partightenfactor0

\f3\fs26 \cf7 \cb5 \strokec7 class\cf8 \strokec8  \cf9 \strokec9 Solution\cf8 \strokec8 :\
    \cf7 \strokec7 def\cf8 \strokec8  \cf10 \strokec10 threeSum\cf8 \strokec8 (\cf9 \strokec9 self, nums: List[int]\cf8 \strokec8 ) -> List[List[int]]:\
        res = []\
        nums.sort()\
        \
        \cf7 \strokec7 for\cf8 \strokec8  i \cf7 \strokec7 in\cf8 \strokec8  \cf9 \strokec9 range\cf8 \strokec8 (\cf9 \strokec9 len\cf8 \strokec8 (nums)-\cf10 \strokec10 2\cf8 \strokec8 ):\
            \cf7 \strokec7 if\cf8 \strokec8  i > \cf10 \strokec10 0\cf8 \strokec8  \cf7 \strokec7 and\cf8 \strokec8  nums[i] == nums[i-\cf10 \strokec10 1\cf8 \strokec8 ]:\
                \cf7 \strokec7 continue\cf8 \strokec8 \
            output_2sum = self.twoSum(nums[i+\cf10 \strokec10 1\cf8 \strokec8 :], -nums[i])\
            \cf7 \strokec7 if\cf8 \strokec8  output_2sum ==[]:\
                \cf7 \strokec7 continue\cf8 \strokec8 \
            \cf7 \strokec7 else\cf8 \strokec8 :\
                \cf7 \strokec7 for\cf8 \strokec8  idx \cf7 \strokec7 in\cf8 \strokec8  output_2sum:\
                    instance = idx+[nums[i]]\
                    res.append(instance)\
        \
        output = []\
        \cf7 \strokec7 for\cf8 \strokec8  idx \cf7 \strokec7 in\cf8 \strokec8  res:\
            \cf7 \strokec7 if\cf8 \strokec8  idx \cf7 \strokec7 not\cf8 \strokec8  \cf7 \strokec7 in\cf8 \strokec8  output:\
                output.append(idx)\
                \
        \
        \cf7 \strokec7 return\cf8 \strokec8  output\
    \
    \
    \cf7 \strokec7 def\cf8 \strokec8  \cf10 \strokec10 twoSum\cf8 \strokec8 (\cf9 \strokec9 self, nums, target\cf8 \strokec8 ):\
        seen = \{\}\
        res = []\
        \cf7 \strokec7 for\cf8 \strokec8  i, value \cf7 \strokec7 in\cf8 \strokec8  \cf9 \strokec9 enumerate\cf8 \strokec8 (nums): \cf11 \strokec11 #1\cf8 \strokec8 \
            remaining = target - nums[i] \cf11 \strokec11 #2\cf8 \strokec8 \
           \
            \cf7 \strokec7 if\cf8 \strokec8  remaining \cf7 \strokec7 in\cf8 \strokec8  seen: \cf11 \strokec11 #3\cf8 \strokec8 \
                res.append([value, remaining])  \cf11 \strokec11 #4\cf8 \strokec8 \
            \cf7 \strokec7 else\cf8 \strokec8 :\
                seen[value] = i  \cf11 \strokec11 #5\cf8 \strokec8 \
            \
        \cf7 \strokec7 return\cf8 \strokec8  res\
\pard\pardeftab720\sa280\partightenfactor0

\f0\fs28 \cf2 \cb3 \strokec2 \
\pard\pardeftab720\sa280\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://leetcode.com/problems/4sum/"}}{\fldrslt 
\f2\b \cf6 \strokec6 4Sum}}\
\
You should have gotten the idea, and what you've seen so far can be generalized to\'a0
\f1\fs26 \cf4 \cb5 \strokec4 nSum
\f0\fs28 \cf2 \cb3 \strokec2 . Here, I write the generic code using the same ideas as before. What I'll do is to break down each case to a\'a0
\f1\fs26 \cf4 \cb5 \strokec4 2Sum II
\f0\fs28 \cf2 \cb3 \strokec2 \'a0problem, and solve them recursively using the approach in\'a0
\f1\fs26 \cf4 \cb5 \strokec4 2Sum II
\f0\fs28 \cf2 \cb3 \strokec2 \'a0example above.\
\
First sort\'a0
\f1\fs26 \cf4 \cb5 \strokec4 nums
\f0\fs28 \cf2 \cb3 \strokec2 , then I'm using two extra functions,\'a0
\f1\fs26 \cf4 \cb5 \strokec4 helper
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and\'a0
\f1\fs26 \cf4 \cb5 \strokec4 twoSum
\f0\fs28 \cf2 \cb3 \strokec2 . The\'a0
\f1\fs26 \cf4 \cb5 \strokec4 twoSum
\f0\fs28 \cf2 \cb3 \strokec2 \'a0is similar to the\'a0
\f1\fs26 \cf4 \cb5 \strokec4 2sum II
\f0\fs28 \cf2 \cb3 \strokec2 \'a0example with some modifications. It doesn't return the first instance of results, it check every possible combinations and return all of them now. Basically, now it's more similar to the\'a0
\f1\fs26 \cf4 \cb5 \strokec4 3Sum
\f0\fs28 \cf2 \cb3 \strokec2 \'a0solution. Understanding this function shouldn't be difficult as it's very similar to\'a0
\f1\fs26 \cf4 \cb5 \strokec4 3Sum
\f0\fs28 \cf2 \cb3 \strokec2 . As for\'a0
\f1\fs26 \cf4 \cb5 \strokec4 helper
\f0\fs28 \cf2 \cb3 \strokec2 \'a0function, it first tries to check for cases that don't work (line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #1
\f0\fs28 \cf2 \cb3 \strokec2 ). And later, if the\'a0
\f1\fs26 \cf4 \cb5 \strokec4 N
\f0\fs28 \cf2 \cb3 \strokec2 \'a0we need to sum to get to a\'a0
\f1\fs26 \cf4 \cb5 \strokec4 target
\f0\fs28 \cf2 \cb3 \strokec2 \'a0is 2 (line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #2
\f0\fs28 \cf2 \cb3 \strokec2 ), then runs the\'a0
\f1\fs26 \cf4 \cb5 \strokec4 twoSum
\f0\fs28 \cf2 \cb3 \strokec2 \'a0function. For the more than two numbers, it recursively breaks them down to two sum (line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #3
\f0\fs28 \cf2 \cb3 \strokec2 ). There are some cases like line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #4
\f0\fs28 \cf2 \cb3 \strokec2 \'a0that we don't need to proceed with the algorithm anymore and we can\'a0
\f1\fs26 \cf4 \cb5 \strokec4 break
\f0\fs28 \cf2 \cb3 \strokec2 . These cases include if multiplying the lowest number in the list by\'a0
\f1\fs26 \cf4 \cb5 \strokec4 N
\f0\fs28 \cf2 \cb3 \strokec2 \'a0is more than\'a0
\f1\fs26 \cf4 \cb5 \strokec4 target
\f0\fs28 \cf2 \cb3 \strokec2 . Since its sorted array, if this happens, we can't find any result. Also, if the largest array (
\f1\fs26 \cf4 \cb5 \strokec4 nums[-1]
\f0\fs28 \cf2 \cb3 \strokec2 ) multiplied by\'a0
\f1\fs26 \cf4 \cb5 \strokec4 N
\f0\fs28 \cf2 \cb3 \strokec2 \'a0would be less than\'a0
\f1\fs26 \cf4 \cb5 \strokec4 target
\f0\fs28 \cf2 \cb3 \strokec2 , we can't find any solution. So,\'a0
\f1\fs26 \cf4 \cb5 \strokec4 break
\f0\fs28 \cf2 \cb3 \strokec2 .\
\
For other cases, we run the\'a0
\f1\fs26 \cf4 \cb5 \strokec4 helper
\f0\fs28 \cf2 \cb3 \strokec2 \'a0function again with new inputs, and we keep doing it until we get to\'a0
\f1\fs26 \cf4 \cb5 \strokec4 N=2
\f0\fs28 \cf2 \cb3 \strokec2 \'a0in which we use\'a0
\f1\fs26 \cf4 \cb5 \strokec4 twoSum
\f0\fs28 \cf2 \cb3 \strokec2 \'a0function, and add the results to get the final output.\
\
\pard\pardeftab720\sl416\partightenfactor0

\f3\fs26 \cf7 \cb5 \strokec7 class\cf8 \strokec8  \cf9 \strokec9 Solution\cf8 \strokec8 :\
    \cf7 \strokec7 def\cf8 \strokec8  \cf10 \strokec10 fourSum\cf8 \strokec8 (\cf9 \strokec9 self, nums: List[int], target: int\cf8 \strokec8 ) -> List[List[int]]:\
        nums.sort()\
        results = []\
        self.helper(nums, target, \cf10 \strokec10 4\cf8 \strokec8 , [], results)\
        \cf7 \strokec7 return\cf8 \strokec8  results\
    \
    \cf7 \strokec7 def\cf8 \strokec8  \cf10 \strokec10 helper\cf8 \strokec8 (\cf9 \strokec9 self, nums, target, N, res, results\cf8 \strokec8 ):\
        \
        \cf7 \strokec7 if\cf8 \strokec8  \cf9 \strokec9 len\cf8 \strokec8 (nums) < N \cf7 \strokec7 or\cf8 \strokec8  N < \cf10 \strokec10 2\cf8 \strokec8 : \cf11 \strokec11 #1\cf8 \strokec8 \
            \cf7 \strokec7 return\cf8 \strokec8 \
        \cf7 \strokec7 if\cf8 \strokec8  N == \cf10 \strokec10 2\cf8 \strokec8 : \cf11 \strokec11 #2\cf8 \strokec8 \
            output_2sum = self.twoSum(nums, target)\
            \cf7 \strokec7 if\cf8 \strokec8  output_2sum != []:\
                \cf7 \strokec7 for\cf8 \strokec8  idx \cf7 \strokec7 in\cf8 \strokec8  output_2sum:\
                    results.append(res + idx)\
        \
        \cf7 \strokec7 else\cf8 \strokec8 : \
            \cf7 \strokec7 for\cf8 \strokec8  i \cf7 \strokec7 in\cf8 \strokec8  \cf9 \strokec9 range\cf8 \strokec8 (\cf9 \strokec9 len\cf8 \strokec8 (nums) -N +\cf10 \strokec10 1\cf8 \strokec8 ): \cf11 \strokec11 #3\cf8 \strokec8 \
                \cf7 \strokec7 if\cf8 \strokec8  nums[i]*N > target \cf7 \strokec7 or\cf8 \strokec8  nums[-\cf10 \strokec10 1\cf8 \strokec8 ]*N < target: \cf11 \strokec11 #4\cf8 \strokec8 \
                    \cf7 \strokec7 break\cf8 \strokec8 \
                \cf7 \strokec7 if\cf8 \strokec8  i == \cf10 \strokec10 0\cf8 \strokec8  \cf7 \strokec7 or\cf8 \strokec8  i > \cf10 \strokec10 0\cf8 \strokec8  \cf7 \strokec7 and\cf8 \strokec8  nums[i-\cf10 \strokec10 1\cf8 \strokec8 ] != nums[i]: \cf11 \strokec11 #5\cf8 \strokec8 \
                    self.helper(nums[i+\cf10 \strokec10 1\cf8 \strokec8 :], target-nums[i], N-\cf10 \strokec10 1\cf8 \strokec8 , res + [nums[i]], results)\
    \
    \
    \cf7 \strokec7 def\cf8 \strokec8  \cf10 \strokec10 twoSum\cf8 \strokec8 (\cf9 \strokec9 self, nums: List[int], target: int\cf8 \strokec8 ) -> List[int]:\
        res = []\
        left = \cf10 \strokec10 0\cf8 \strokec8 \
        right = \cf9 \strokec9 len\cf8 \strokec8 (nums) - \cf10 \strokec10 1\cf8 \strokec8  \
        \cf7 \strokec7 while\cf8 \strokec8  left < right: \
            temp_sum = nums[left] + nums[right] \
\
            \cf7 \strokec7 if\cf8 \strokec8  temp_sum == target:\
                res.append([nums[left], nums[right]])\
                right -= \cf10 \strokec10 1\cf8 \strokec8 \
                left += \cf10 \strokec10 1\cf8 \strokec8 \
                \cf7 \strokec7 while\cf8 \strokec8  left < right \cf7 \strokec7 and\cf8 \strokec8  nums[left] == nums[left - \cf10 \strokec10 1\cf8 \strokec8 ]:\
                    left += \cf10 \strokec10 1\cf8 \strokec8 \
                \cf7 \strokec7 while\cf8 \strokec8  right > left \cf7 \strokec7 and\cf8 \strokec8  nums[right] == nums[right + \cf10 \strokec10 1\cf8 \strokec8 ]:\
                    right -= \cf10 \strokec10 1\cf8 \strokec8 \
                                \
            \cf7 \strokec7 elif\cf8 \strokec8  temp_sum < target: \
                left +=\cf10 \strokec10 1\cf8 \strokec8  \
            \cf7 \strokec7 else\cf8 \strokec8 : \
                right -= \cf10 \strokec10 1\cf8 \strokec8 \
                                        \
        \cf7 \strokec7 return\cf8 \strokec8  res\
\pard\pardeftab720\sa280\partightenfactor0

\f0\fs28 \cf2 \cb3 \strokec2 \
\pard\pardeftab720\sa280\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://leetcode.com/problems/combination-sum-ii/"}}{\fldrslt 
\f2\b \cf6 \strokec6 Combination Sum II}}\cb1 \uc0\u8232 \cb3 I don't post combination sum here since it's basically this problem a little bit easier.\cb1 \uc0\u8232 \cb3 Combination questions can be solved with\'a0
\f1\fs26 \cf4 \cb5 \strokec4 dfs
\f0\fs28 \cf2 \cb3 \strokec2 \'a0most of the time. if you want to fully understand this concept and\'a0{\field{\*\fldinst{HYPERLINK "https://www.***.org/backtracking-introduction/"}}{\fldrslt \cf6 \strokec6 backtracking}}, try to finish\'a0{\field{\*\fldinst{HYPERLINK "https://leetcode.com/problems/combination-sum/discuss/429538/General-Backtracking-questions-solutions-in-Python-for-reference-%3A"}}{\fldrslt \cf6 \strokec6 this}}\'a0post and do all the examples.\
\
Read my older post first\'a0{\field{\*\fldinst{HYPERLINK "https://leetcode.com/problems/combinations/discuss/729397/python3-solution-with-detailed-explanation"}}{\fldrslt \cf6 \strokec6 here}}. This should give you a better idea of what's going on. The solution here also follow the exact same format except for some minor changes. I first made a minor change in the\'a0
\f1\fs26 \cf4 \cb5 \strokec4 dfs
\f0\fs28 \cf2 \cb3 \strokec2 \'a0function where it doesn't need the\'a0
\f1\fs26 \cf4 \cb5 \strokec4 index
\f0\fs28 \cf2 \cb3 \strokec2 \'a0parameter anymore. This is taken care of by\'a0
\f1\fs26 \cf4 \cb5 \strokec4 candidates[i+1:]
\f0\fs28 \cf2 \cb3 \strokec2 \'a0in line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #3
\f0\fs28 \cf2 \cb3 \strokec2 . Note that we had\'a0
\f1\fs26 \cf4 \cb5 \strokec4 candidates
\f0\fs28 \cf2 \cb3 \strokec2 \'a0here in the previous post.\
\
\pard\pardeftab720\sl416\partightenfactor0

\f3\fs26 \cf7 \cb5 \strokec7 class\cf8 \strokec8  \cf9 \strokec9 Solution\cf8 \strokec8 (\cf9 \strokec9 object\cf8 \strokec8 ):\
    \cf7 \strokec7 def\cf8 \strokec8  \cf10 \strokec10 combinationSum2\cf8 \strokec8 (\cf9 \strokec9 self, candidates, target\cf8 \strokec8 ):\
        \cf12 \strokec12 """\
        :type candidates: List[int]\
        :type target: int\
        :rtype: List[List[int]]\
        """\cf8 \strokec8 \
        res = []\
        candidates.sort()\
        self.dfs(candidates, target, [], res)\
        \cf7 \strokec7 return\cf8 \strokec8  res\
    \
    \
    \cf7 \strokec7 def\cf8 \strokec8  \cf10 \strokec10 dfs\cf8 \strokec8 (\cf9 \strokec9 self, candidates, target, path, res\cf8 \strokec8 ):\
        \cf7 \strokec7 if\cf8 \strokec8  target < \cf10 \strokec10 0\cf8 \strokec8 :\
            \cf7 \strokec7 return\cf8 \strokec8 \
        \
        \cf7 \strokec7 if\cf8 \strokec8  target == \cf10 \strokec10 0\cf8 \strokec8 :\
            res.append(path)\
            \cf7 \strokec7 return\cf8 \strokec8  res\
        \
        \cf7 \strokec7 for\cf8 \strokec8  i \cf7 \strokec7 in\cf8 \strokec8  \cf9 \strokec9 range\cf8 \strokec8 (\cf9 \strokec9 len\cf8 \strokec8 (candidates)):\
            \cf7 \strokec7 if\cf8 \strokec8  i > \cf10 \strokec10 0\cf8 \strokec8  \cf7 \strokec7 and\cf8 \strokec8  candidates[i] == candidates[i-\cf10 \strokec10 1\cf8 \strokec8 ]: \cf11 \strokec11 #1\cf8 \strokec8 \
                \cf7 \strokec7 continue\cf8 \strokec8  \cf11 \strokec11 #2\cf8 \strokec8 \
            self.dfs(candidates[i+\cf10 \strokec10 1\cf8 \strokec8 :], target - candidates[i], path+[candidates[i]], res) \cf11 \strokec11 #3\cf8 \strokec8 \
\pard\pardeftab720\sa280\partightenfactor0

\f0\fs28 \cf2 \cb3 \strokec2 \
The only differences are lines\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #1, 2, 3
\f0\fs28 \cf2 \cb3 \strokec2 . The difference in problem statement in this one and\'a0
\f1\fs26 \cf4 \cb5 \strokec4 combinations
\f0\fs28 \cf2 \cb3 \strokec2 \'a0problem of my previous post is >>>candidates must be used once<<< and lines\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #1
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and\'a0
\f1\fs26 \cf4 \cb5 \strokec4 2
\f0\fs28 \cf2 \cb3 \strokec2 \'a0are here to take care of this. Line\'a0
\f1\fs26 \cf4 \cb5 \strokec4 #1
\f0\fs28 \cf2 \cb3 \strokec2 \'a0has two components where first\'a0
\f1\fs26 \cf4 \cb5 \strokec4 i > 0
\f0\fs28 \cf2 \cb3 \strokec2 \'a0and second\'a0
\f1\fs26 \cf4 \cb5 \strokec4 candidates[i] == candidates[i-1]
\f0\fs28 \cf2 \cb3 \strokec2 . The second component\'a0
\f1\fs26 \cf4 \cb5 \strokec4 candidates[i] == candidates[i-1]
\f0\fs28 \cf2 \cb3 \strokec2 \'a0is to take care of duplicates in the\'a0
\f1\fs26 \cf4 \cb5 \strokec4 candidates
\f0\fs28 \cf2 \cb3 \strokec2 \'a0variable as was instructed in the problem statement. Basically, if the next number in\'a0
\f1\fs26 \cf4 \cb5 \strokec4 candidates
\f0\fs28 \cf2 \cb3 \strokec2 \'a0is the same as the previous one, it means that it has already been taken care of, so\'a0
\f1\fs26 \cf4 \cb5 \strokec4 continue
\f0\fs28 \cf2 \cb3 \strokec2 . The first component takes care of cases like an input\'a0
\f1\fs26 \cf4 \cb5 \strokec4 candidates = [1]
\f0\fs28 \cf2 \cb3 \strokec2 \'a0with\'a0
\f1\fs26 \cf4 \cb5 \strokec4 target = 1
\f0\fs28 \cf2 \cb3 \strokec2 \'a0(try to remove this component and submit your solution. You'll see what I mean). The rest is similar to the previous\'a0{\field{\*\fldinst{HYPERLINK "https://leetcode.com/problems/combinations/discuss/729397/python3-solution-with-detailed-explanation"}}{\fldrslt \cf6 \strokec6 post}}\
}