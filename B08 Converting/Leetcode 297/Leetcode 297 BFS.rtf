{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 HelveticaNeue;}
{\colortbl;\red255\green255\blue255;\red151\green0\blue126;\red245\green247\blue249;\red29\green38\blue42;
\red73\green17\blue135;\red20\green0\blue196;\red12\green90\blue1;\red181\green0\blue19;\red51\green51\blue51;
\red255\green255\blue255;}
{\*\expandedcolortbl;;\cssrgb\c66667\c5098\c56863;\cssrgb\c96863\c97647\c98039;\cssrgb\c14902\c19608\c21961;
\cssrgb\c36078\c14902\c60000;\cssrgb\c10980\c0\c81176;\cssrgb\c0\c41569\c0;\cssrgb\c76863\c10196\c8627;\cssrgb\c25882\c25882\c25882;
\cssrgb\c100000\c100000\c100000;}
\margl1440\margr1440\vieww25100\viewh13280\viewkind0
\deftab720
\pard\pardeftab720\sl416\partightenfactor0

\f0\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 class\cf4 \strokec4  \cf5 \strokec5 Codec\cf4 \strokec4 :\
\
    \cf2 \strokec2 def\cf4 \strokec4  \cf6 \strokec6 serialize\cf4 \strokec4 (\cf5 \strokec5 self, root\cf4 \strokec4 ):\
        \cf7 \strokec7 # use level order traversal to match LeetCode's serialization format\cf4 \strokec4 \
        flat_bt = []\
        queue = collections.deque([root])\
        \cf2 \strokec2 while\cf4 \strokec4  queue:\
            node = queue.pop()\
            \cf2 \strokec2 if\cf4 \strokec4  node:\
                flat_bt.append(\cf5 \strokec5 str\cf4 \strokec4 (node.val))\
                queue.appendleft(node.left)\
                queue.appendleft(node.right)\
            \cf2 \strokec2 else\cf4 \strokec4 :\
                \cf7 \strokec7 # you can use any char to represent null\cf4 \strokec4 \
                \cf7 \strokec7 # empty string means test for a non-null node is simply: flat_bt[i]\cf4 \strokec4 \
                flat_bt.append(\cf8 \strokec8 ''\cf4 \strokec4 )\
        \cf2 \strokec2 return\cf4 \strokec4  \cf8 \strokec8 ','\cf4 \strokec4 .join(flat_bt)\
    \cf7 \strokec7 # time:  O(n)\cf4 \strokec4 \
    \cf7 \strokec7 # space: O(n)\cf4 \strokec4 \
\
    \cf2 \strokec2 def\cf4 \strokec4  \cf6 \strokec6 deserialize\cf4 \strokec4 (\cf5 \strokec5 self, data\cf4 \strokec4 ):\
        \cf2 \strokec2 if\cf4 \strokec4  \cf2 \strokec2 not\cf4 \strokec4  data:\
            \cf2 \strokec2 return\cf4 \strokec4 \
        flat_bt = data.split(\cf8 \strokec8 ','\cf4 \strokec4 )\
        ans = TreeNode(flat_bt[\cf6 \strokec6 0\cf4 \strokec4 ])\
        queue = collections.deque([ans])\
        i = \cf6 \strokec6 1\cf4 \strokec4 \
        \cf7 \strokec7 # when you pop a node, its children will be at i and i+1\cf4 \strokec4 \
        \cf2 \strokec2 while\cf4 \strokec4  queue:\
            node = queue.pop()\
            \cf2 \strokec2 if\cf4 \strokec4  i < \cf5 \strokec5 len\cf4 \strokec4 (flat_bt) \cf2 \strokec2 and\cf4 \strokec4  flat_bt[i]:\
                node.left = TreeNode(\cf5 \strokec5 int\cf4 \strokec4 (flat_bt[i]))\
                queue.appendleft(node.left)\
            i += \cf6 \strokec6 1\cf4 \strokec4 \
            \cf2 \strokec2 if\cf4 \strokec4  i < \cf5 \strokec5 len\cf4 \strokec4 (flat_bt) \cf2 \strokec2 and\cf4 \strokec4  flat_bt[i]:\
                node.right = TreeNode(\cf5 \strokec5 int\cf4 \strokec4 (flat_bt[i]))\
                queue.appendleft(node.right)\
            i += \cf6 \strokec6 1\cf4 \strokec4 \
        \cf2 \strokec2 return\cf4 \strokec4  ans\
    \cf7 \strokec7 # time:  O(n)\cf4 \strokec4 \
    \cf7 \strokec7 # space: O(n)\cf4 \strokec4 \
\pard\pardeftab720\sa280\partightenfactor0

\f1\fs28 \cf9 \cb10 \strokec9 \
}