{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Medium;\f1\fnil\fcharset0 HelveticaNeue;\f2\fnil\fcharset0 Menlo-Regular;
\f3\fnil\fcharset0 HelveticaNeue-Bold;\f4\fmodern\fcharset0 Courier;\f5\fnil\fcharset0 HelveticaNeue-Italic;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;\red51\green51\blue51;
\red151\green0\blue126;\red245\green247\blue249;\red29\green38\blue42;\red73\green17\blue135;\red20\green0\blue196;
\red67\green91\blue103;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0\c85098;\cssrgb\c100000\c100000\c100000;\cssrgb\c25882\c25882\c25882;
\cssrgb\c66667\c5098\c56863;\cssrgb\c96863\c97647\c98039;\cssrgb\c14902\c19608\c21961;\cssrgb\c36078\c14902\c60000;\cssrgb\c10980\c0\c81176;
\cssrgb\c32941\c43137\c47843;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sa120\partightenfactor0

\f0\fs24 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 1. Iterative\
\pard\pardeftab720\sa280\partightenfactor0

\f1\fs28 \cf4 \strokec4 \
O(n) complexity, O(1) space\
\
\pard\pardeftab720\sl400\partightenfactor0

\f2\fs26 \cf5 \cb6 \strokec5 class\cf7 \strokec7  \cf8 \strokec8 Solution\cf7 \strokec7 :\
    \cf5 \strokec5 def\cf7 \strokec7  \cf9 \strokec9 fib\cf7 \strokec7 (\cf8 \strokec8 self, N: int\cf7 \strokec7 ) -> int:\
        a, b = \cf9 \strokec9 0\cf7 \strokec7 , \cf9 \strokec9 1\cf7 \strokec7 \
        \cf5 \strokec5 for\cf7 \strokec7  _ \cf5 \strokec5 in\cf7 \strokec7  \cf8 \strokec8 range\cf7 \strokec7 (N):\
            a, b = b, a+b\
        \cf5 \strokec5 return\cf7 \strokec7  a\
\pard\pardeftab720\sa280\partightenfactor0

\f1\fs28 \cf4 \cb3 \strokec4 \
\pard\pardeftab720\sa280\partightenfactor0

\f3\b \cf4 1.0: O(1) space
\f1\b0 \cb1 \uc0\u8232 \cb3 Since we only need the previous two numbers to compute the next fib number, there is no need to create an extra array to store all fibs.\
\

\f3\b 1.1: why returning a not b
\f1\b0 \cb1 \uc0\u8232 
\f4\fs26 \cf10 \cb6 \strokec10 a
\f1\fs28 \cf4 \cb3 \strokec4 \'a0is the\'a0
\f5\i 0th
\f1\i0 \'a0fib number, after N times assignment in the for loop,\'a0
\f4\fs26 \cf10 \cb6 \strokec10 a
\f1\fs28 \cf4 \cb3 \strokec4 \'a0would eventually become the\'a0
\f5\i Nth
\f1\i0 \'a0fib number asked in the question.\
\
######\
\pard\pardeftab720\sa120\partightenfactor0

\f0\fs24 \cf2 \strokec2 2. Recursive\
\pard\pardeftab720\sa280\partightenfactor0

\f1\fs28 \cf4 \strokec4 \
O(n) complexity, O(n) space\
\
\pard\pardeftab720\sl400\partightenfactor0

\f2\fs26 \cf7 \cb6 \strokec7 cache = \{\cf9 \strokec9 0\cf7 \strokec7 : \cf9 \strokec9 0\cf7 \strokec7 , \cf9 \strokec9 1\cf7 \strokec7 : \cf9 \strokec9 1\cf7 \strokec7 \}\
\cf5 \strokec5 class\cf7 \strokec7  \cf8 \strokec8 Solution\cf7 \strokec7 :\
    \cf5 \strokec5 def\cf7 \strokec7  \cf9 \strokec9 fib\cf7 \strokec7 (\cf8 \strokec8 self, N: int\cf7 \strokec7 ) -> int:\
        \cf5 \strokec5 if\cf7 \strokec7  N \cf5 \strokec5 in\cf7 \strokec7  cache:\
            \cf5 \strokec5 return\cf7 \strokec7  self.cache[N]\
        val = self.fib(N-\cf9 \strokec9 1\cf7 \strokec7 ) + self.fib(N-\cf9 \strokec9 2\cf7 \strokec7 )\
        cache[N] = val\
        \cf5 \strokec5 return\cf7 \strokec7  val\
\pard\pardeftab720\sa280\partightenfactor0

\f1\fs28 \cf4 \cb3 \strokec4 \
}