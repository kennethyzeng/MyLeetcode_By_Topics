{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 HelveticaNeue-Bold;\f2\fnil\fcharset0 HelveticaNeue;
\f3\fnil\fcharset0 Menlo-Regular;\f4\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red51\green51\blue51;\red255\green255\blue255;\red29\green38\blue42;
\red245\green247\blue249;\red67\green91\blue103;}
{\*\expandedcolortbl;;\cssrgb\c25882\c25882\c25882;\cssrgb\c100000\c100000\c100000;\cssrgb\c14902\c19608\c21961;
\cssrgb\c96863\c97647\c98039;\cssrgb\c32941\c43137\c47843;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\vieww12000\viewh15840\viewkind0
\deftab720
\pard\pardeftab720\sl276\slmult1\sa200\partightenfactor0

\f0\fs22 \cf0 ###############################Link###########################################\
https://www.youtube.com/watch?v=euO5pWQtqNQ\
################################Approach######################################\
###############################Algorithms######################################\
\
################################Other###########################################\
\pard\pardeftab720\partightenfactor0

\f1\b\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
Explanation/Discussion:
\f2\b0 \
\pard\pardeftab720\sa280\partightenfactor0
\cf2 \
Consider this input:\
\
\pard\pardeftab720\sl416\partightenfactor0

\f3\fs26 \cf4 \cb5 preorder: [1, 2, 4, 5, 3, 6]\
inorder: [4, 2, 5, 1, 6, 3]\
\pard\pardeftab720\sa280\partightenfactor0

\f2\fs28 \cf2 \cb3 \
The obvious way to build the tree is:\
\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf2 \kerning1\expnd0\expndtw0 {\listtext	1.	}\expnd0\expndtw0\kerning0
Use the first element of\'a0
\f4\fs26 \cf6 \cb5 preorder
\f2\fs28 \cf2 \cb3 , the\'a0
\f4\fs26 \cf6 \cb5 1
\f2\fs28 \cf2 \cb3 , as root.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	2.	}\expnd0\expndtw0\kerning0
Search it in\'a0
\f4\fs26 \cf6 \cb5 inorder
\f2\fs28 \cf2 \cb3 .\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	3.	}\expnd0\expndtw0\kerning0
Split\'a0
\f4\fs26 \cf6 \cb5 inorder
\f2\fs28 \cf2 \cb3 \'a0by it, here into\'a0
\f4\fs26 \cf6 \cb5 [4, 2, 5]
\f2\fs28 \cf2 \cb3 \'a0and\'a0
\f4\fs26 \cf6 \cb5 [6, 3]
\f2\fs28 \cf2 \cb3 .\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	4.	}\expnd0\expndtw0\kerning0
Split the rest of\'a0
\f4\fs26 \cf6 \cb5 preorder
\f2\fs28 \cf2 \cb3 \'a0into two parts as large as the\'a0
\f4\fs26 \cf6 \cb5 inorder
\f2\fs28 \cf2 \cb3 \'a0parts, here into\'a0
\f4\fs26 \cf6 \cb5 [2, 4, 5]
\f2\fs28 \cf2 \cb3 \'a0and\'a0
\f4\fs26 \cf6 \cb5 [3, 6]
\f2\fs28 \cf2 \cb3 .\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	5.	}\expnd0\expndtw0\kerning0
Use\'a0
\f4\fs26 \cf6 \cb5 preorder = [2, 4, 5]
\f2\fs28 \cf2 \cb3 \'a0and\'a0
\f4\fs26 \cf6 \cb5 inorder = [4, 2, 5]
\f2\fs28 \cf2 \cb3 \'a0to add the left subtree.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	6.	}\expnd0\expndtw0\kerning0
Use\'a0
\f4\fs26 \cf6 \cb5 preorder =
\f2\fs28 \cf2 \cb3 [3, 6]
\f4\fs26 \cf6 \cb5 and
\f2\fs28 \cf2 \cb3 inorder =\'a0
\f4\fs26 \cf6 \cb5 [6, 3]
\f2\fs28 \cf2 \cb3 \'a0to add the right subtree.\cb1 \
\pard\pardeftab720\sa280\partightenfactor0
\cf2 \cb3 \
But consider the worst case for this: A tree that's not balanced but is just a straight line to the left. Then inorder is the reverse of preorder, and already the cost of step 2, searching in\'a0
\f4\fs26 \cf6 \cb5 inorder
\f2\fs28 \cf2 \cb3 , is O(n^2) overall. Also, depending on how you "split" the arrays, you're looking at O(n^2) runtime and possibly O(n^2) space for that as well.\
\
You can bring the runtime for searching down to O(n) by building a map from value to index before you start the main work, and I've seen several solutions do that. But that is O(n) additional space, and also the splitting problems remain. To fix those, you can use pointers into\'a0
\f4\fs26 \cf6 \cb5 preorder
\f2\fs28 \cf2 \cb3 \'a0and\'a0
\f4\fs26 \cf6 \cb5 inorder
\f2\fs28 \cf2 \cb3 \'a0instead of splitting them. And when you're doing that, you don't need the value-to-index map, either.\
\
Consider the example again. Instead of finding the\'a0
\f4\fs26 \cf6 \cb5 1
\f2\fs28 \cf2 \cb3 \'a0in\'a0
\f4\fs26 \cf6 \cb5 inorder
\f2\fs28 \cf2 \cb3 , splitting the arrays into parts and recursing on them, just recurse on the full remaining arrays and\'a0
\f1\b stop
\f2\b0 \'a0when you come across the\'a0
\f4\fs26 \cf6 \cb5 1
\f2\fs28 \cf2 \cb3 \'a0in\'a0
\f4\fs26 \cf6 \cb5 inorder
\f2\fs28 \cf2 \cb3 . That's what my above solution does. Each recursive call gets told where to stop, and it tells its subcalls where to stop. It gives its own root value as stopper to its left subcall and its parent`s stopper as stopper to its right subcall.\
\
############\
\
\
}