{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 HelveticaNeue;\f2\fnil\fcharset0 HelveticaNeue-Bold;
\f3\fmodern\fcharset0 Courier;\f4\fnil\fcharset0 HelveticaNeue-Medium;\f5\fnil\fcharset0 HelveticaNeue-Italic;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;\red29\green38\blue42;
\red255\green255\blue255;\red67\green91\blue103;\red245\green247\blue249;\red25\green25\blue25;\red29\green38\blue42;
}
{\*\expandedcolortbl;;\cssrgb\c0\c1\c1;\cssrgb\c100000\c100000\c99985;\cssrgb\c14902\c19608\c21961;
\cssrgb\c100000\c100000\c100000;\cssrgb\c32941\c43137\c47843;\cssrgb\c96863\c97647\c98039;\cssrgb\c12941\c12941\c12941;\cssrgb\c14902\c19608\c21961;
}
\margl1440\margr1440\vieww13400\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf2 \cb3 #1\
\pard\pardeftab720\partightenfactor0

\f1\fs28 \cf4 \cb5 \expnd0\expndtw0\kerning0
A\'a0
\f2\b height-balanced
\f1\b0 \'a0binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.A\'a0
\f2\b height-balanced
\f1\b0 \'a0binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\
\
#2 Copy list with Random pointer. (Deep copy of linked list)\
\pard\pardeftab720\partightenfactor0
\cf4 The deep copy should consist of exactly\'a0
\f3\fs26 \cf6 \cb7 n
\f1\fs28 \cf4 \cb5 \'a0
\f2\b brand new
\f1\b0 \'a0nodes, where each new node has its value set to the value of its corresponding original node. Both the\'a0
\f3\fs26 \cf6 \cb7 next
\f1\fs28 \cf4 \cb5 \'a0and\'a0
\f3\fs26 \cf6 \cb7 random
\f1\fs28 \cf4 \cb5 \'a0pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state.\'a0
\f2\b None of the pointers in the new list should point to nodes in the original list
\f1\b0 .\
\
For example, if there are two nodes\'a0
\f3\fs26 \cf6 \cb7 X
\f1\fs28 \cf4 \cb5 \'a0and\'a0
\f3\fs26 \cf6 \cb7 Y
\f1\fs28 \cf4 \cb5 \'a0in the original list, where\'a0
\f3\fs26 \cf6 \cb7 X.random --> Y
\f1\fs28 \cf4 \cb5 , then for the corresponding two nodes\'a0
\f3\fs26 \cf6 \cb7 x
\f1\fs28 \cf4 \cb5 \'a0and\'a0
\f3\fs26 \cf6 \cb7 y
\f1\fs28 \cf4 \cb5 \'a0in the copied list,\'a0
\f3\fs26 \cf6 \cb7 x.random --> y
\f1\fs28 \cf4 \cb5 .\
\
\
#3. 
\f4\b\fs32 \cf8 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec8 Binary Tree Zigzag Level Order Traversal
\f1\b0\fs28 \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \
\pard\pardeftab720\sa280\partightenfactor0

\f5\i \cf9 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec9 the zigzag level order traversal of its nodes' values
\f1\i0 . (i.e., from left to right, then right to left for the next level and alternate between).\
\
#4  
\f4\b\fs32 \cf8 \strokec8 Serialize and Deserialize Binary Tree\
\pard\pardeftab720\sa280\partightenfactor0

\f1\b0\fs28 \cf9 \strokec9 Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\
Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\
\pard\pardeftab720\sa280\partightenfactor0
\cf9 \
}